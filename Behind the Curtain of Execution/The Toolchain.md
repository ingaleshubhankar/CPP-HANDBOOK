# [The ToolChain](#the-toolchain)
Imagine you have a brilliant idea, and you decide to bring it to life with a C++ program. You open your favorite text editor, type out a simple program to greet the world, and save it with the .cpp extension. But have you ever wondered what happens behind the scenes to turn that plain text into a running application?

Let me take you on a journey through the toolchain that makes it all possible. Lets first discuss the components of the toolchain and then we will see stepwise description of execution.

 ✓ A Toolchain is the set of Programming Tools that are used to create a softwares.
 <br>
 ✓ The Tools are used in a chain, So that the output of each tool becomes input for the next tool.

<br>


![X86 Toolchain](https://github.com/ingaleshubhankar/CPP-HANDBOOK/blob/main/Behind%20the%20Curtain%20of%20Execution/x84-arch-diagram.png)
<img src="images/example-image.jpg" alt="Resized Image" width="200">

<br>
<br>

## [Components of the Toolchain](#components-of-the-toolchain)

### [Editor](#editor)
 ✓ Editor is program in which we can write our code and edit that code.
 <br>
 ✓ Gedit, kwrite are the example of editors.
<br>

#### Example
Program : **Demo.C**
```
//Header file inclusion
#include<stdio.h>
//Macro definition
#define MAX 10

int Add(int No1, int No2)
{
    //Local variable
    int Ans;

    Ans = No1 + No2 + MAX;
    printf("Addition of Two Numbers is %d",Ans);
    return Ans;
}
```
<br>

### [Preprocessor](#preprocessor)
 ✓ The Preprocessor provides the ability for the inclusion of the header files, macro expansion, conditional compilation and line control.
<br>
 ✓ Preprocessor take lines beginnering with `#` as directives. Because it knows nothing about the underlying language.
<br>
 ✓ After Preprocessing it will give the expanded code as a output having extention **.i**.
<br>
 ✓ Expanded output given by preprocessor is in human understandable format.
<br>

#### Example
Program : **Demo.i**
```
int printf(const char * format,...);
int scanf(const char * format,...);

int Add(int No1, int No2)
{
    int Ans;
    Ans = No1 + No2 +10;
    printf("Addition of Tow Numbers is %d",Ans);
    return Ans;
}
```
<br>

### [Compiler](#compiler)
 ✓ Compiler is a program which is used for transating source code from a high level programming languages (like C, C++) to lower level programming language (like assembly language, machine, machine language).
<br>
 ✓ In this case we consider that output is in assembly language having extension `asm` or `.s`.
<br>
 ✓ Code which is generated by the compiler is machine dependent.
<br>

#### Example
Program : **Demo.asm**
```
Add:PUSH ECX
PUSH EDX
ADD ECX,EDX
ADD ECX,10
MOVE EAX,ECX
RETN
```
<br>
 

### [Assembler](#assembler)
 ✓ Assembler is a program which translates assembly language program to an object file, which contains code in machine language.
<br>
 ✓ Object file contains machine code, But still it is non-executable having extension `.obj`.
<br>

#### Example
Program : **Demo.obj**
```
10010111011010111000
10000001001110100000
00100100010010111000
10010111111010111000
11001100000010111000
10010000011010001011
11110111011010111011
00010100011010111010
10010111011010111011
00010111011010001110
```
<br>


### [Linker](#linker)
 ✓ A Linker is a program that takes one or more object files and combines them into a single executable program having extension `.exe`.
<br>
 ✓ Linker adds primary header over executable file which contains address of entry point funtion, magic number, time-date stamp, type of executable (Executable can be self-executable or dependable executable).
<br>

#### Example
Program : **File.exe**
<br>

File1 : Demo.obj
```
10010111011010111000
10000001001110100000
00100100010010111000
10010111111010111000
11001100000010111000
10010000011010001011
11110111011010111011
00010100011010111010
10010111011010111011
00010111011010001110
```
<br>

Other.obj
```
11110111011010111000
10000111101110100000
00000100010010111000
10010111111010110101
11111100000010101010
00000000011010001011
11110111011010111011
00010100011010111010
10010111011010111011
10000111011010001110
```
<br>

Demo.exe
```
10010111011010111000
10000001001110100000
00100100010010111000
10010111111010111000
11001100000010111000
10010000011010001011
11110111011010111011
00010100011010111010
10010111011010111011
00010111011010001110
```
<br>



### [Loader](#loader)
 ✓ A Loader is a program which is is part of operating system that is responsible for loadind programs.
<br>
 ✓ It praoces program in memory (RAM) and prepares them for execution.
<br>
 ✓ Loading a program involves reading the contents of execution file like text, data into the memory.
<br>

#### Example
Program : **Demo.exe** running in RAM
```
10010111011010111000
10000001001110100000
00100100010010111000
10010111111010111000
11001100000010111000
10010000011010001011
11110111011010111011
00010100011010111010
10010111011010111011
00010111011010001110
```
<br>
<br>


## [Stepwise execution of Toolchain](#stepwise-execution-of-toolchain)

**Step 1:** First we write a program in any programming language like C/C++ on editor and then save program. When we save the program with appropriate file extension like .c / .cpp get stored in hard disk in format of file (File is unformatted uniform stream of bytes).
<br>
In this step program is in human understandable format. And our task is to convert this format to machine understandable format i.e Machine language.
<br>
<br>

**Step 2:** To achieve this first we pass our program to the preprocessor. Preprocessor gives the expanded source code as a output. But still our program is in human understandable format.
<br>
<br>

**Step 3:** After preprocessing we pass the expanded program to the compiler which gives output in assembly language which is hardware dependent language. But still out program is in machine language.
<br>
<br>

**Step 4:** This is assembly language program is pass to the assembler which converts assembly language program into machine language called as object code.
<br>
This is not pure executable code. This object file is divided into three parts as Text, Data & Symbol Table.
<br>
Text section is a section which contains compiled instructions of our program in machine understandable format.
<br>
Data section contains all the golbal variabl and static variables of our program. Data section is internally divided into two parts as bss(Block starting with Symbol) and non bss(Block starting with Value).
<br>
bss section contains all non-initialized global variables and non bss section contains all initialized global variables.
<br>
Symbol table is a data structure which is used to maintain all the information of indentifiers used in our program.
<br>
<br>

**Step 5:** After getting the object code we pass this file to the linker. Linker is responsible for creating executable file.
<br>
Linkers link our object code with other dependent object code. It also adds primary header to our executable file. Primary header is a structure which contains magic number, type of executable, address of entry point, time date stamp etc.
<br>
Magic number is a number which is used by operating system to uniquely indentify the executablle.
<br>
After getting output of linker our file is in executable format but it is stored in harddisk.
<br>
But if we want to run this program it must be copied into the main memory i.e RAM.
<br>
<br>

**Step 6:** Loader is part of operating system which is responsible for loading the program from hard disk to RAM.
<br>
When our program geets loaded into the ram its primary header gets removed and instructions pointer is set to the address of entry point.
<br>
New section gets added which is called as stack which contains information of function. There is seperate stack frame for each and every function whcich contains information like local variables, argument of functions, old value of EBP, address of next instruction to be executed etc.
<br>

| Memory layout process |
|:-----:|
|![Memory layout process](https://github.com/ingaleshubhankar/CPP-HANDBOOK/blob/main/Behind%20the%20Curtain%20of%20Execution/memory_layout_process.png) |

<br>

**Step 7:** Now our program gets copied into the memory. For further processing we have to pass that program to CPU. But it is not possible to pass whole program to CPU because of memory constrains. because of which each and evert section of program get converted into the segment of small size.
<br>
<br>
Segement of texxt section gets copied into CS(Code Segement), segement of data segement gets copied into DS(Data Segement), and stack segement gets copied into SS(Stack Segement).
<br>
If there is more space required to store the segment then ES(Extra segment), DS,GS(There is not full forms) are used.
<br>
<br>

**Step 8:** Now contents of this segment gets converted into set of instructions. And the instructions are stored in queue called as instruction queue.
<br>
There is a IP (Instruction Pointer) who's responsible for featching the instruction from instruction queue and pass for further processing.
<br>
<br>

**Step 9:** Now this instruction is accepted by CU (Control Unit). If the instruction is arithmatic instruction then it is handled by ALU (Arithmatic Logical Unit).
<br>
<br>

**Step 10:** To process the instructions temporary memory locations of processor are used called CPU registers.
<br>
<br>

---